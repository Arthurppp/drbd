#!/bin/sh
#
# chkconfig: 345 30 70
# description: Loads and unloads the drbd module
#
# Copyright (C) 1999 2000, Philipp Reisner <philipp@linuxfreak.com>.
# Initial author.
#
# Copyright (C) 2000, Fábio Olivé Leite <olive@conectiva.com.br>
# Changes to support multiple devices and different distributions.
# Changes to increase robustness and exit with proper error values.
#
# Some ideas and inspiration from Joe Hartley <jh@brainiac.com>

# Source function library.
# Some distributions don't have it, so test and act accordingly

INSTALL="/etc/ha.d/resource.d"
. $INSTALL/drbd_commun

# Source networking configuration.
if [ -f /etc/sysconfig/network ]; then
	. /etc/sysconfig/network
	# Check that networking is up.
	if [ "$NETWORKING" = "no" ]; then
		echo drbd: networking is down!
		exit 1
	fi
fi
# If the distribution does not have sysconfig/network, let's hope
# networking is up.

# Check for drbdsetup
if [ ! -x /usr/sbin/drbdsetup ]; then
	echo drbd: drbdsetup not found!
	exit 1
fi

# Check for drbd's module
if [ ! -f /lib/modules/`uname -r`/block/drbd.o ]; then
	echo drbd: module not found!
	exit 1
fi

# Check for our config directory
if [ ! -d $CONFIG ]; then
	echo drbd: configuration directory not found!
	exit 1
fi

cd $CONFIG
DEVICES=`ls drbd[0-9] 2>/dev/null`

# RETVAL will work as a "stuck bit" for any error. The construct
# RV=$?
# [ $RETVAL -eq 0 ] && RETVAL=$RV
# allows us to have it stuck at 1 when some error occur, even if
# subsequent operations don't fail. Using $RV prevents us from getting
# the exit value of [ ... ]. That was a dumb one... :)
RETVAL=0	# this means there were errors
RV=0		# this means there were errors in the current device
MINOR_COUNT=`echo $DEVICES | wc --words | sed -e s/\ //g`

# See how we were called.
case "$1" in
  start)
  	# use -s in modprobe/rmmod to keep errors in the logs
	action "Loading DRBD module" /sbin/modprobe -s drbd \
            minor_count=$MINOR_COUNT
	[ $? -ne 0 ] && exit 1

	for D in $DEVICES; do
	    . $D

	    if [ -z "$NODE1_IF" ]; then
                NODE1_IF=$NODE1_HOST;
		fi

	    if [ -z "$NODE2_IF" ]; then
                NODE2_IF=$NODE2_HOST;
		fi


		setLocal

		action "Configuring DRBD resource $D" \
		    /usr/sbin/drbdsetup $LOCAL_DEVICE $LOCAL_PARTITION \
	    $PROTOCOL $LOCAL_IF $REMOTE_IF $OPTIONS 
		RV=$?
		[ $RETVAL -eq 0 ] && RETVAL=$RV

	    if [ ! isMasterBoot $D ]; then
			if [ $RV -eq 0 ]; then
			echo -n "Waiting for drdb to initialize (Can not fail)"
			sleep 30
			success
			
			# don't wait if there was an error in this device
			action "Waiting for DRBD resource $D to resynchronize" \
			    /usr/sbin/drbdsetup $LOCAL_DEVICE WAIT
		else
			succed "Node is master nothing to sync"
		fi
	done
	;;
  stop)
	action "Unloading DRBD module" /sbin/rmmod -s drbd
	RETVAL=$?
	;;
  restart)
	$0 stop
	$0 start
	RETVAL=$?
	;;
  status)
	if [ -r /proc/drbd ]; then
		cat /proc/drbd
	else
		echo "DRBD module not loaded."
		RETVAL=1
	fi
	;;
  *)
	echo "Usage: $0 {start|stop|restart|status}"
	RETVAL=1
	;;
esac

exit $RETVAL

