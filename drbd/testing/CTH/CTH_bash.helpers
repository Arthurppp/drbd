#!/bin/bash -nv
# $Id: CTH_bash.helpers,v 1.1.2.8 2004/06/07 10:16:39 lars Exp $
#
# define some implicit magic
# so the definition of the DRBDs will be easier
#

clear_env()
{
	ID_DISK=0
	ID_DRBD=0
	ID_BDEV=0
	DRBD_CONF=""
	unset ${!Node_*} ${!Link_*} ${!Disk_*} ${!Drbd_*} ${!Bdev_*}
	unset ${!FS_*} ${!RS_*} ${!H_*} ${!Fmt_*}

	# field name headers for display in _gen_comp()
	Fmt_Node="(%-15s %-12s %-10s %9s %10s)"
	  H_Node=(admin_ip hostname admin_nic timeout min_uptime)
	Fmt_Disk="(%-8s %-8s %-24s)"
	  H_Disk=(name Node real_dev)
	Fmt_Link="\n#\t(%-8s %-15s %-6s)"
	  H_Link=(Node ip nic)
	Fmt_Drbd="(%-8s %-5s %6s %-8s\n#\t  %-8s %-15s %-24s %-8s\n#\t  %-8s %-15s %-24s %-8s)"
	  H_Drbd=(name minor port link
		left left_ip left_real_dev left_disk
		right right_ip right_real_dev right_disk
		conf)
}
link_for_each_node()
{
	local link=$1 doit=$2
	eval "set -- \"\${$link[@]}\""
	while (( $# )) ; do
		node=$1 ip=$2 nic=$3 ; shift 3
		node_to_env $node
		eval "$doit"
	done
}
ip_of()
{
	local link=$1 node=$2
	eval "set -- \"\${$link[@]}\""
	while (( $# )) ; do
		[[ $1 == $node ]] && echo $2 && return
		shift 3
	done
	return 1
}
node_to_env()
{
	eval "set -- \"\${$1[@]}\""
	  admin_ip=$1
	  hostname=$2
	 admin_nic=$3
	   timeout=$4	# boot_timeout
	min_uptime=$5
}
disk_to_env()
{
	eval "set -- \"\${$1[@]}\""
	    name=$1
	    node=$2
	real_dev=$3
	DEV=$real_dev
}
bdev_to_env()
{
	local b=$1
	case $b in
	Drbd_*) drbd_to_env $b ;;
	Bdev_*) DEV=/dev/mapper/${!b} ;;
	*)	echo >&2 "sorry, I don't know about bdev '$b'"; return 1 ;;
	esac
}
drbd_to_env()
{
	eval "set -- \"\${$1[@]}\""
	   name=$1
	  minor=$2
	   port=$3
	   link=$4
	shift 4;  left=$1  left_ip=$2  left_real_dev=$3  left_disk=$4
	shift 4; right=$1 right_ip=$2 right_real_dev=$3 right_disk=$4
	   conf=$5
	DEV=/dev/nb$minor
}
new_bdev()
{
	local name node real_dev disk bdev
	name=$1 ; shift

	bdev="$name"
	while (( $# )) ; do
		[[ $1 == *:/* ]] || return 101
		node=${1%%:*} ; real_dev=${1#*:} ; shift
		let ID_DISK++
		disk="Disk_$ID_DISK"
		eval "$disk=( $name $node  $real_dev )"
		bdev="$bdev $node $real_dev"
	done
	let ID_BDEV++
	eval "Bdev_$ID_BDEV=($bdev)"
}	
new_drbd()
{
	local name minor port left left_real_dev right right_real_dev link
	local  left_ip  left_hostname  left_disk
	local right_ip right_hostname right_disk conf
	          name=$1
	         minor=$2
		  port=$3
	          left=$4
	 left_real_dev=$5
	         right=$6
	right_real_dev=$7
	          link=$8

	 left_ip=$(ip_of $link $left)  || return
	right_ip=$(ip_of $link $right) || return
	node_to_env $left  ;  left_hostname=$hostname
	node_to_env $right ; right_hostname=$hostname

	let ID_DISK++
	left_disk="Disk_$ID_DISK"
	eval "$left_disk=( $name $left  $left_real_dev )"
	let ID_DISK++
	right_disk="Disk_$ID_DISK"
       	eval "$right_disk=( $name $right $right_real_dev )"

	# funny quoting with cat
	conf=$(cat <<-___

		resource $name {
		    protocol        C;
		    incon-degr-cmd "reboot -f";
		    on $left_hostname {
		        device         /dev/nb$minor;
		        disk           /dev/mapper/$name;
		        address        $left_ip:$port;
		        meta-disk      internal;
		    }
		    on $right_hostname {
		        device         /dev/nb$minor;
		        disk           /dev/mapper/$name;
		        address        $right_ip:$port;
		        meta-disk      internal;
		    }
		    net {
		        connect-int    10;
		        max-buffers    32;
		        max-epoch-size 2048;
		        ping-int       10;
		        sndbuf-size    131070;
		        timeout        60;
		    }
		    disk {
		        on-io-error    detach;
		    }
		    syncer {
		        al-extents     257;
		        group          1;
		        rate           30M;
		    }
		    startup {
		        degr-wfc-timeout 120;
		    }
		}
		___
	)

	let ID_DRBD++
	eval "Drbd_$ID_DRBD=($name $minor $port
		$link
		$left
		$left_ip
		$left_real_dev
		$left_disk
		$right
		$right_ip
		$right_real_dev
		$right_disk
		\"\$conf\"
	)"
}	


Crash_Node()
{
	local n=$1
	on ${!n}: generic_do_crash
}

Wait_for_boot()
{
	local n=$1
	node_to_env $n
	ip=$admin_ip
	generic_wait_for_boot
}

cat_proc_blah()
{
	cat /proc/{drbd,loadavg,meminfo} 2>&1
	grep "drbd\|xfs\|reiser\|ext" /proc/slabinfo
}
Node_State()
{
	on ${!1}: cat_proc_blah
}

Fail_Link()
{
	local l=$1
	link_for_each_node $l 'on ${!node}: iptables_DROP   nic=$nic hostname=$hostname'
}

Heal_Link()
{
	local l=$1
	link_for_each_node $l 'on ${!node}: iptables_UNDROP   nic=$nic hostname=$hostname'
}

Fail_Disk()
{
	local d=$1
	disk_to_env $d
	on ${!node}: dmsetup_error name=$name dev=$real_dev
}

Heal_Disk()
{
	local d=$1
	disk_to_env $d
	on ${!node}: dmsetup_linear name=$name dev=$real_dev
}

# initial boot
boot_and_setup_nodes()
{ (
	set -e
	initial=true
	[[ ${!Drbd_*} ]] && have_drbd=true || have_drbd=false # FIXME should be node specific...
	for n in ${!Node_*}; do
		node_to_env $n
		ip=$admin_ip
		echo "looking for $hostname ($ip)"
		generic_wait_for_boot
	done

	# undrop all links
	for l in ${!Link_*} ; do Heal_Link $l ; done

	# configure all dm disks
	for d in ${!Disk_*} ; do Heal_Disk $d ; done

	# reset and up all DRBDs
	for d in ${!Drbd_*} ; do
		drbd_to_env $d
		echo "$conf" | on ${!left}:  drbd_append_config NAME=$name RES=$name LO_DEV=$left_real_dev
		echo "$conf" | on ${!right}: drbd_append_config NAME=$name RES=$name LO_DEV=$right_real_dev
	done

	# wait for connect and initial sync (which should be skipped automatically)
	for d in ${!Drbd_*} ; do
		drbd_to_env $d
		on ${!left}:  drbd_wait_sync minor=$minor
		# on ${!right}: drbd_wait_sync minor=$minor
	done

	# make file systems
	for fs in ${!FS_*} ; do
		eval ${!fs}
		# fixme add paranoia, should check for availability on the
		# respective node
		bdev_to_env $BDEV
		if [[ $BDEV == Drbd_* ]] ; then
			n=$left
			on ${!n}: drbdadm_pri   name=$name
		else
			n=Node_1
		fi
		cat <<-___
		#
		# on $n: mkfs.$TYPE $DEV
		#
		___
		on ${!n}: mkfs_$TYPE    DEV=$DEV
		if [[ $BDEV == Drbd_* ]] ; then
			on ${!n}: drbdadm_sec   name=$name
		fi
	done

	initial=false
) }

Start()
{
	local rs=$1 nn=$2
	i=${rs#RS_}
	which=${!rs}; [[ $which == *CN=* ]] && cn=${which#*CN=} || cn=''
	fs=FS_$i; CN=""
	eval ${!fs}

	[[ -z $CN && -z $cn ]] || return 101
	[[ $nn == Node_* ]]    || return 102

	# fixme add paranoia, should check for availability on the
	# respective node
	bdev_to_env $BDEV
	if [[ $BDEV == Drbd_* ]] ; then
		on ${!nn}: drbd_wait_peer_not_pri minor=$minor
		on ${!nn}: drbdadm_pri   name=$name
	else
		: "do something to make $BDEV available?"
	fi
	on ${!nn}: do_mount      DEV=$DEV TYPE=$TYPE MNT=$MNT

	# START IN BACKGROUND
	on ${!nn}: ${which}_start   MNT=$MNT </dev/null &

	# rememeber current node
	eval "$fs=\"\$$fs CN=$nn\""
	eval "$rs=\"\$$rs CN=$nn\""

	echo "$rs now RUNNING on $nn"
	Dump_RS
}

Stop()
{
	local rs=$1 i fs cn CN which
	i=${rs#RS_}
	which=${!rs}; [[ $which == *CN=* ]] && cn=${which#*CN=} || cn=''
	fs=FS_$i; CN=""
	eval "${!fs}"

	[[ -z $CN || -z $cn ]] && return 101
	[[ $CN == $cn ]]       || return 102
	[[ $cn == Node_* ]]    || return 103

	bdev_to_env $BDEV
	on ${!cn}: generic_test_stop MNT=$MNT
	on ${!cn}: do_umount         MNT=$MNT
	if [[ $BDEV == Drbd_* ]] ; then
		on ${!cn}: drbdadm_sec       name=$name
	else
		: "do something to make $BDEV unavailable?"
	fi
	eval "$fs=\${$fs% CN=*}"   # forget current node
	eval "$rs=\${$rs% CN=*}"   # forget current node
	Dump_RS
}

Reloc()
{
	local rs=$1 nn=$2 cn
	if [[ ${!rs} == *CN=* ]] ; then
		cn=${!rs}; cn=${rs#*CN=}
		if [[ $cn == $nn ]] ; then
			echo "$rs already running on $nn"
			Dump_RS
		       	return
		fi
		Stop $rs
	fi
	Start $rs $nn
}

# for verification
Dump_long()
{
	echo "$1=("
	eval "printf '\t%s\n' \"\${$1[@]}\""
	echo ")"
}
Dump()
{
	local v=$1 f
	[[ $v == H_* ]] && f=Fmt_${v#H_}
	[[ $f ]] || f=Fmt_${v%_*}
	eval "set -- \"\${$v[@]::12}\""
	if [[ $v == H_* ]] ; then
		printf "\n# %7s" ""
	else
		printf "# %s=" "$v"
	fi
	printf "${!f}" "$@"
	echo
}
Dump_All()
{
	local c
	for n in ${!Node_*} ${!Link_*} ${!Disk_*} ${!Drbd_*} ; do
		if [[ ${n%_*} != $c ]] ; then
			c=${n%_*}
			Dump H_$c
		fi
		Dump $n
	done
}
Dump_RS()
{
	for r in ${!RS_*}; do
		printf "%s=%q\n" "$r" "${!r}"
	done
}

Help()
{
	cat <<-___
	#
	#  start something on some node:
	#     Start RS_1 Node_1
	#
	#  relocate it:
	#     Reloc RS_1 Node_2
	#
	#  stop it again:
	#     Stop RS_1
	#
	#  sleep \$for_a_while # ;-)
	#
	#  fail and heal hardware:
	#     Crash_Node    Node_#
	#     Wait_for_boot Node_#
	#     Fail_Link Link_#
	#     Heal_Link Link_#
	#     Fail_Disk Disk_#
	#     Heal_Disk Disk_#
	#
	# see this text again:
	#     Help  # <<=== note the capital H
	# 
	# see your resources:
	#     Dump_RS
	# 
	# ask for
	#     Node_State Node_1
	#
___
}

# interactive TAB completion
_dump_comp()
{
	local c=$1
	if (( ${#COMPREPLY[*]} )); then
		echo
		Dump H_$c
		for v in "${COMPREPLY[@]}" ; do
			Dump $v
		done
		echo -n "$PS2${COMP_WORDS[*]}"
	fi
}
_start_and_reloc_comp()
{
	local v
	eval "v=\${!${COMP_WORDS[COMP_CWORD]}*}"
	if (( COMP_CWORD <= 1 )) ; then
		COMPREPLY=(${v:-${!RS_*}})
	elif (( COMP_CWORD <= 2 )) ; then
		COMPREPLY=(${v:-${!Node_*}})
		_dump_comp Node
	else
		COMPREPLY=()
	fi
}
_gen_comp()
{
	local v c
	case $COMP_WORDS in
		Node_State|\
		Wait_for_boot|\
		Crash_Node)	c=Node ;;
		*_Disk)		c=Disk ;;
		*_Link)		c=Link ;;
	esac
	if (( COMP_CWORD <= 1 )) ; then
		eval "v=\${!${COMP_WORDS[COMP_CWORD]}*}"
		if [[ $v ]] ; then
			COMPREPLY=($v)
		else
			eval "COMPREPLY=(\${!${c}_*})"
		fi
		_dump_comp $c
	else
		COMPREPLY=()
	fi
}
#complete -v -X '!Node_*' Node_State Crash_Node Wait_for_boot
#complete -v -X '!Link_*' Fail_Link Heal_Link
#complete -v -X '!Disk_*' Fail_Disk Heal_Disk
complete -v -X '![DLN][ior]*' Dump Dump_long
complete -v -X '!RS_*'   Stop
complete -F _gen_comp Fail_Disk Heal_Disk Fail_Link Heal_Link
complete -F _gen_comp Crash_Node Node_State Wait_for_boot
complete -F _start_and_reloc_comp Start Reloc

