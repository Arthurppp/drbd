#!/bin/bash -nv
# $Id: CTH_bash.helpers,v 1.1.2.2 2004/05/27 17:46:58 lars Exp $
#
# define some implicit magic
# so the definition of the DRBDs will be easier
#

ID_DISK=0
ID_DRBD=0
DRBD_CONF=""
link_for_each_node()
{
	local link=$1 doit=$2
	eval "set -- \"\${$link[@]}\""
	while (( $# )) ; do
		node=$1 ip=$2 nic=$3 ; shift 3
		node_to_env $node
		eval "$doit"
	done
}
ip_of()
{
	local link=$1 node=$2
	eval "set -- \"\${$link[@]}\""
	while (( $# )) ; do
		[[ $1 == $node ]] && echo $2 && return
		shift 3
	done
	return 1
}
node_to_env()
{
	eval "set -- \"\${$1[@]}\""
	   admin_ip=$1
	   hostname=$2
	  admin_nic=$3
	    timeout=$4	# boot_timeout
	min_uptimre=$5
}
disk_to_env()
{
	eval "set -- \"\${$1[@]}\""
	    name=$1
	    node=$2
	real_dev=$3
}
drbd_to_env()
{
	eval "set -- \"\${$1[@]}\""
	   name=$1
	  minor=$2
	   port=$3
	   link=$4
	shift 4;  left=$1  left_ip=$2  left_real_dev=$3  left_disk=$4
	shift 4; right=$1 right_ip=$2 right_real_dev=$3 right_disk=$4
	   conf=$5
}
new_drbd()
{
	local name minor port left left_real_dev right right_real_dev link
	local  left_ip  left_hostname  left_disk
	local right_ip right_hostname right_disk conf
	          name=$1
	         minor=$2
		  port=$3
	          left=$4
	 left_real_dev=$5
	         right=$6
	right_real_dev=$7
	          link=$8

	# unfortunately the ${!xx} operator only gives the [0] array field
	# but since thats the IP by definition, this works.
	 left_ip=$(ip_of $link $left)  || return
	right_ip=$(ip_of $link $right) || return
	node_to_env $left  ;  left_hostname=$hostname
	node_to_env $right ; right_hostname=$hostname

	let ID_DISK++
	left_disk="Disk_$ID_DISK"
	eval "$left_disk=( $name $left  $left_real_dev )"
	let ID_DISK++
	right_disk="Disk_$ID_DISK"
       	eval "$right_disk=( $name $right $right_real_dev )"

	# funny quoting with cat
	conf=$(cat <<-___
		resource $name {
		    protocol        C;
		    incon-degr-cmd "reboot -f";
		    on $left_hostname {
		        device         /dev/nb$minor;
		        disk           /dev/mapper/$name;
		        address        $left_ip:$port;
		        meta-disk      internal;
		    }
		    on $right_hostname {
		        device         /dev/nb$minor;
		        disk           /dev/mapper/$name;
		        address        $right_ip:$port;
		        meta-disk      internal;
		    }
		    net {
		        connect-int    10;
		        max-buffers    32;
		        max-epoch-size 2048;
		        ping-int       10;
		        sndbuf-size    131070;
		        timeout        60;
		    }
		    disk {
		        on-io-error    detach;
		    }
		    syncer {
		        al-extents     257;
		        group          1;
		        rate           30M;
		    }
		    startup {
		        degr-wfc-timeout 120;
		    }
		}
		___
	)

	let ID_DRBD++
	eval "Drbd_$ID_DRBD=($name $minor $port
		$link
		$left
		$left_ip
		$left_real_dev
		$left_disk
		$right
		$right_ip
		$right_real_dev
		$right_disk
		\"\$conf\"
	)"
}	


crash_Node()
{
	local n=$1
	on ${!n}: generic_do_crash
}

wait_for_boot()
{
	local n=$1
	node_to_env $n
	on ${!n}: generic_do_crash
	ip=$admin_ip
	generic_wait_for_boot
}

fail_Link()
{
	local l=$1
	link_for_each_node $l 'on ${!node}: iptables_DROP   nic=$nic hostname=$hostname'
}

heal_Link()
{
	local l=$1
	link_for_each_node $l 'on ${!node}: iptables_UNDROP   nic=$nic hostname=$hostname'
}

fail_Disk()
{
	local d=$1
	disk_to_env $d
	on ${!node}: dmsetup_error name=$name dev=$real_dev
}

heal_Disk()
{
	local d=$1
	disk_to_env $d
	on ${!node}: dmsetup_linear name=$name dev=$real_dev
}

# initial boot
boot_and_setup_nodes()
{
	initial=true
	for n in ${!Node_*}; do
		node_to_env $n
		ip=$admin_ip
		generic_wait_for_boot
	done

	# undrop all links
	for l in ${!Link_*} ; do heal_Link $l ; done

	# configure all dm disks
	for d in ${!Disk_*} ; do heal_Disk $d ; done

	# reset and up all DRBDs
	for d in ${!Drbd_*} ; do
		drbd_to_env $d
		echo "$conf" | on ${!left}:  drbd_append_config NAME=$name RES=$name LO_DEV=$left_real_dev
		echo "$conf" | on ${!right}: drbd_append_config NAME=$name RES=$name LO_DEV=$right_real_dev
	done

	# wait for connect and initial sync (which should be skipped automatically)
	for d in ${!Drbd_*} ; do
		drbd_to_env $d
		on ${!left}:  drbd_wait_sync minor=$minor
		# on ${!right}: drbd_wait_sync minor=$minor
	done

	# make file systems
	for fs in ${!FS_*} ; do
		eval ${!fs}
		drbd_to_env $DRBD
		n=$left
		on ${!n}: drbdadm_pri   name=$name
		cat <<-___
		#
		# on $n: mkfs.$TYPE /dev/nb$minor
		#
		___
		on ${!n}: mkfs_$TYPE    DEV=/dev/nb$minor
		on ${!n}: drbdadm_sec   name=$name
	done

	initial=false
}

resource_Start_on_Node()
{
	local rs=$1 nn=$2
	i=${rs#RS_}
	which=${!rs}; [[ $which == *CN=* ]] && cn=${which#*CN=} || cn=''
	fs=FS_$i; CN=""
	eval ${!fs}

	[[ -z $CN && -z $cn ]] || exit 101
	[[ $nn == Node_* ]]    || exit 102

	drbd_to_env $DRBD
	on ${!nn}: drbdadm_pri   name=$name
	on ${!nn}: do_mount      DEV=/dev/nb$minor TYPE=$TYPE MNT=$MNT

	# START IN BACKGROUND
	on ${!nn}: ${which}_start   MNT=$MNT &

	# rememeber current node
	eval "$fs=\"\$$fs CN=$nn\""
	eval "$rs=\"\$$rs CN=$nn\""

	echo "$rs now RUNNING on $nn"
}

resource_Stop()
{
	local rs=$1
	i=${rs#RS_}
	which=${!rs}; [[ $which == *CN=* ]] && cn=${which#*CN=} || cn=''
	fs=FS_$i; CN=""
	eval "${!fs}"

	[[ -z $CN || -z $cn ]] && exit 101
	[[ $CN == $cn ]]       || exit 102
	[[ $cn == Node_* ]]    || exit 103

	drbd_to_env $DRBD
	on ${!cn}: generic_test_stop MNT=$MNT
	on ${!cn}: do_umount         MNT=$MNT
	on ${!cn}: drbdadm_sec       name=$name
	eval "$fs=\${$fs% CN=*}"   # forget current node
	eval "$rs=\${$rs% CN=*}"   # forget current node
}

resource_relocate_to_Node()
{
	local rs=$1 nn=$2
	if [[ ${!rs} == *CN=* ]] ; then
		resource_Stop $rs
	fi
	resource_Start_on_Node $rs $nn
}

# for verification
Dump()
{
	echo "$1=("
	eval "printf '\t%s\n' \"\${$1[@]}\""
	echo ")"
}
Dump_All()
{
	for n in ${!Node_*} ${!Link_*} ${!Disk_*} ${!Drbd_*} ; do
		Dump $n
	done
}
